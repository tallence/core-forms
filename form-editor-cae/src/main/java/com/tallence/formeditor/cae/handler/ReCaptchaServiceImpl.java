package com.tallence.formeditor.cae.handler;

import com.coremedia.blueprint.common.contentbeans.CMNavigation;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.MultiValueMap;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Collection;

/**
 * Encapsulates requests to google reCaptcha.
 */
public class ReCaptchaServiceImpl implements CaptchaService {

  private static final Logger LOG = LoggerFactory.getLogger(ReCaptchaServiceImpl.class);

  private static final String RECAPTCHA_URL = "https://www.google.com/recaptcha/api/siteverify";
  private static final String CHARSET_UTF_8 = StandardCharsets.UTF_8.name();

  private final ReCaptchaAuthentication defaultCredentials;

  public ReCaptchaServiceImpl(ReCaptchaAuthentication defaultCredentials) {
    this.defaultCredentials = defaultCredentials;
  }

  /**
   * Resolves the website-secret for google reCaptcha for the given Context.
   * <p>
   * The context is currently ignored. Use it if you need multiple secrets for your sites.
   */
  public String getWebsiteSecretForSite(CMNavigation currentContext) {
    return defaultCredentials.websiteSecret;
  }

  /**
   * Resolves the server-secret for google reCaptcha for the given Context.
   * <p>
   * The context is currently ignored. Use it if you need multiple secrets for your sites.
   */
  private String getServerSecretForSite(CMNavigation currentContext) {
    return defaultCredentials.serverSecret;
  }

  /**
   * Asks the Google Recaptcha Service, if the given googleReCaptchaResponse is valid.
   *
   * @param postData contains the token, generated by the reCaptcha widget, by using the public key
   * @return true, if the google reCaptcha service validates the request, false otherwise.
   */
  @Override
  public boolean isHuman(MultiValueMap<String, String> postData, CMNavigation currentContext) {

    URLConnection connection;
    String query;
    String googleReCaptchaResponse = postData.get("g-recaptcha-response").get(0);
    try {
      query = String.format("secret=%s&response=%s",
          URLEncoder.encode(getServerSecretForSite(currentContext), CHARSET_UTF_8),
          URLEncoder.encode(googleReCaptchaResponse, CHARSET_UTF_8));
      connection = new URL(RECAPTCHA_URL + "?" + query).openConnection();
      connection.setConnectTimeout(5 * 1000);
      connection.setReadTimeout(5 * 1000);
    } catch (Exception e) {
      LOG.error("Error during opening google connection for param: " + googleReCaptchaResponse, e);
      return false;
    }

    try (InputStream is = connection.getInputStream()) {
      BufferedReader reader = new BufferedReader(new InputStreamReader(is, CHARSET_UTF_8));
      StringBuilder stringBuilder = new StringBuilder();
      String inputStr;
      while ((inputStr = reader.readLine()) != null) {
        stringBuilder.append(inputStr);
      }
      return new ObjectMapper().readValue(stringBuilder.toString(), ReCaptchaResponse.class).success;
    } catch (Exception e) {
      LOG.error("Error during connecting the google reCaptcha Service", e);
      return false;
    }
  }

  public static class ReCaptchaAuthentication {
    private final String websiteSecret;
    private final String serverSecret;

    public ReCaptchaAuthentication(String websiteSecret, String serverSecret) {
      this.websiteSecret = websiteSecret;
      this.serverSecret = serverSecret;
    }
  }

  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class ReCaptchaResponse {
    @JsonProperty("success")
    private boolean success;
    @JsonProperty("error-codes")
    private Collection<String> errorCodes;

    public boolean isSuccess() {
      return success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
    }

    public Collection<String> getErrorCodes() {
      return errorCodes;
    }

    public void setErrorCodes(Collection<String> errorCodes) {
      this.errorCodes = errorCodes;
    }
  }

}
